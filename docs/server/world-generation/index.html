<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="World Generation Bestia integrates a specialized library called WorldGen for world creation. It is a clusterable generator which is cabable of dividing the world creation workload onto multiple, different machines. With this framework it should be possible to create million of square kilometers without hitting any memory limit on the servers during the creation process.
In general it works by creating piplines which are then used to create and transform noise maps.">
<meta name="theme-color" content="#FFFFFF"><meta property="og:title" content="" />
<meta property="og:description" content="World Generation Bestia integrates a specialized library called WorldGen for world creation. It is a clusterable generator which is cabable of dividing the world creation workload onto multiple, different machines. With this framework it should be possible to create million of square kilometers without hitting any memory limit on the servers during the creation process.
In general it works by creating piplines which are then used to create and transform noise maps." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://docs.bestia-game.net/docs/server/world-generation/" />
<meta property="article:modified_time" content="2020-05-16T19:48:32+02:00" />
<title>World Generation | Bestia Game</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/book.min.a6e2c98d287fde1ee03cdb4322ae00297d9842c96ed7d383b48098da94e04095.css" integrity="sha256-puLJjSh/3h7gPNtDIq4AKX2YQslu19ODtICY2pTgQJU=">
<script defer src="/en.search.min.f7a632b80386dd73249155e4840027e1bc94e8000fea2fbe7b4590e6ad7cb4db.js" integrity="sha256-96YyuAOG3XMkkVXkhAAn4byU6AAP6i&#43;&#43;e0WQ5q18tNs="></script>

<script defer src="/sw.min.74a8bb07f0bee86d6bb9a2750f073f14d93c7e4512f28860370cfd879e9719b4.js" integrity="sha256-dKi7B/C&#43;6G1ruaJ1Dwc/FNk8fkUS8ohgNwz9h56XGbQ="></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/github-markdown-css/2.2.1/github-markdown.css" />
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="container flex">
    <aside class="book-menu">
      
  <nav>
<h2 class="book-brand">
  <a href="/"><img src="/bestia-logo.svg" alt="Logo" /><span>Bestia Game</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>











  <ul>
<li>
  <a href="/docs/mechanics/"><strong>Game Design</strong></a>
<ul>
<li>
  <a href="/docs/mechanics/general/">General Mechanics</a></li>
<li>
  <a href="/docs/mechanics/master/">Bestia Master</a></li>
<li>
  <a href="/docs/mechanics/bestia/">Bestia</a></li>
<li>
  <a href="/docs/mechanics/environment/">Environment</a></li>
<li>
  <a href="/docs/mechanics/items/">Items</a></li>
<li>
  <a href="/docs/mechanics/resources/">Resources</a></li>
<li>
  <a href="/docs/mechanics/skills/">Skills</a></li>
<li>
  <a href="/docs/mechanics/statusvalues/">Status Values</a></li>
<li>
  <a href="/docs/mechanics/dev-resources/">Development Resources</a></li>
</ul>
</li>
<li>
  <a href="/docs/client/"><strong>Client</strong></a>
<ul>
<li>
  <a href="/docs/client/entities/">Entities</a></li>
</ul>
</li>
<li>
  <a href="/docs/server/"><strong>Server</strong></a>
<ul>
<li>
  <a href="/docs/server/architecture/">Architecture</a></li>
<li>
  <a href="/docs/server/ai/">Artificial Intelligence</a></li>
<li>
  <a href="/docs/server/battle/">Battle</a></li>
<li>
  <a href="/docs/server/quests/">Quests</a></li>
<li>
  <a href="/docs/server/scripting/">Scripting</a></li>
<li>
  <a href="/docs/server/world-generation/"class=active>World Generation</a></li>
</ul>
</li>
<li>
  <a href="/docs/api/"><strong>REST API</strong></a></li>
</ul>










</nav>




  <script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script>


 
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>World Generation</strong>

  <label for="toc-control">
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
  </label>
</div>


  
    <input type="checkbox" class="hidden" id="toc-control" />
    <aside class="hidden clearfix">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#world-generation">World Generation</a>
      <ul>
        <li><a href="#world-generation-algorithm">World Generation Algorithm</a></li>
        <li><a href="#base-parameter">Base Parameter</a></li>
        <li><a href="#noise-maps">Noise Maps</a>
          <ul>
            <li><a href="#height-map">Height Map</a></li>
            <li><a href="#humidity-map">Humidity Map</a></li>
            <li><a href="#temperature-map">Temperature Map</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>


    </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="world-generation">World Generation</h1>
<p>Bestia integrates a specialized library called <strong>WorldGen</strong> for world creation. It is a clusterable generator which is cabable of dividing the world creation workload onto multiple, different machines. With this framework it should be possible to create million of square kilometers without hitting any memory limit on the servers during the creation process.</p>
<p>In general it works by creating piplines which are then used to create and transform noise maps. After the noise was modified and generated the map data is created and saved to the Bestia database in chunks via the <strong>Voxel</strong> module.</p>
<h2 id="world-generation-algorithm">World Generation Algorithm</h2>
<p>There is basically a pipeline in order to generate the Bestia map, these steps are listed here and described below:</p>
<ol>
<li>Setup of Base Parameters</li>
<li>Creating of noise maps based on base parameters
<ol>
<li>Height Map</li>
<li>Humidity Map</li>
<li>Temperature Map</li>
<li>Mana Map</li>
<li>Population Map</li>
</ol>
</li>
<li>Sealevel</li>
<li>Creating Rivers and Lakes</li>
<li>Erosion Simulation</li>
<li>Biome Setup</li>
<li>Terrain Features</li>
<li>Settlement Creation</li>
<li>Resource Distribution</li>
<li>Navigation Map Creation</li>
</ol>
<h2 id="base-parameter">Base Parameter</h2>
<p>The following base parameters are used to generate the map:</p>
<ul>
<li>Total Population 
<link rel="stylesheet" href="/katex/katex.min.css" />
<script defer src="/katex/katex.min.js"></script>
<script defer src="/katex/auto-render.min.js" onload="renderMathInElement(document.body);"></script><span>
  \(P\)
</span>
</li>
<li>World Size <span>
  \(W\)
</span>
 (Depends on expected player count)</li>
<li>Count of Settlements <span>
  \(C\)
</span>
</li>
<li>Seed Value <span>
  \(S\)
</span>
</li>
<li>Maximum Terrain Height <span>
  \(h\)
</span>
</li>
<li>Seelevel (Normalnull) <span>
  \(N\)
</span>
</li>
</ul>
<p>The base parameter are generated randomly based on the expected active player count. They are persisted in the database together with some additional map parameters like creation date or name of the world (to keep some kind of history record).</p>
<h2 id="noise-maps">Noise Maps</h2>
<p>The following noise maps are created by the help of 
  <a href="https://de.wikipedia.org/wiki/Simplex_Noise">OpenSimplexNoise</a> and saved in a shared data storage temporarly until world map generation is finished. In order to save memory its advisable to delete this maps as soon as possible.</p>
<p>Depending on the case the resolution of the heightmaps might be differnt in order to be as memory efficient as possible.</p>
<h3 id="height-map">Height Map</h3>
<p>The heightmap <span>
  \(M_h\)
</span>
 consists of multiple high and low resolution maps which are added and then normalized to a value between 0-1. The lower resolution should have a frequency of about 2-5m. The highest resolution should have a frequency of roughly 4-5km, to give a sense of a &ldquo;big&rdquo; world. Consider maybe 2-3 resolutions in between which a decrease in amplitude.</p>
<p>To calculate the final hight multiply this hight with the maximum map height.</p>
<span>
  \[height = M_{h} \cdot h\]
</span>

<blockquote>
<p>Heightmap resolution is 1m.</p>
</blockquote>
<h3 id="humidity-map">Humidity Map</h3>
<p>The humidity map <span>
  \(M_{hum}\)
</span>
 represents the total annual rainfall between 0-1. The more the humidity is the more snow or rain fall is to be expected (depending on the temperature).</p>
<p>The humidity map is saved in a reduced resolution for later reference for the dynamic environment simulation.</p>
<p>It slightly reduces the humidity based on the height of the terrain like so:</p>
<span>
  \[hum = M_{hum} - 0.4 \cdot M_h\]
</span>

<blockquote>
<p>Humidity resolution 100m.</p>
</blockquote>
<h3 id="temperature-map">Temperature Map</h3>
<p>The temperature map <span>
  \(M_t{&lt; /katex &gt;}} represents the annual average temperature between 0-1.
We assume a desired temperature range of -40 to 40 degree. This is shifted of about &#43;/- 10 degrees randomly upon world creation.

As our temperature map initially holds values between 0-1 the conversion is done like:

&lt;span&gt;
  \[t = M_t \cdot 80 - 40\]
&lt;/span&gt;


The temperature is just created as the other maps but then a gradient is added which will increase the temperature towards the middle (equator) of the map by 130% and drop down to top and bottom to 30% of the original value. An example gradient is shown below:

![Example temperature gradient](gradient.png)

It reduces the temperature the higher the hightmap value is down to a value of 10% by the formula:

&lt;span&gt;
  \[t = M_t - 0.9 \cdot M_h\]
&lt;/span&gt;


&gt; Humidity resolution 100m.

### Mana Map

The mana distribution &lt;span&gt;
  \(M_m{&amp;lt; /katex &amp;gt;}} is a normal noise map without any changes.

&amp;gt; Mana resolution 10m.

### Population Map

The population distribution &amp;lt;span&amp;gt;
  \(M_p{&amp;amp;lt; /katex &amp;amp;gt;}} is a normal noise map without any changes. But is later heavily modified by influence maps.

&amp;amp;gt; Population resolution 100m.

## Sealevel

The sealevel should chosen that oceans vs landmass ratio is about 20:80. This could be calculated but for now we just assume a fixed height value. Every terrain below is covered by water, the rest is landmass.

## Creating Rivers and Lakes

Water always flows downhill. In order to simulate the water flow random sources of water are placed at elevated points in the map and then the water flow is simulated down the slope of the terrain.

In order to find the coordiante of a water sources on a map, the probability P of a coordiante is given by:

* P increases at heights above NN max is 0.6 and then decreases above
* P increases with humidity above 0.5 - 1.0 from 1.0 to 3.0


## Erosion Simulation

Its loosly based on the [SIGGRAPH 2017](https://www.youtube.com/watch?v=9NXL48-Fbb8&amp;amp;amp;t=1009s) talk. In short random events a placed on the map like a water droplet. This droplet follows the slope downwards a hill and is able to pickup material. If it has reached its maximum carry capacity it starts to deposit a certain material amount again. A good explaination is found in [Coding Adventures: Hydraulic Erosion](https://www.youtube.com/watch?v=eaXk97ujbPQ).

## Biome Setup

&amp;amp;gt; Note: For the biome calculation you need to calculate the ranges from the given absolute value in the noise map space.

| Biome        | Height [m]     | Temp. [°C]   | Hum.        | Special |
| ------------ | -------------- | ------------ | ----------- | ------- |
| ICE_DESERT   | 0 - &amp;amp;amp;infin;    | -&amp;amp;amp;infin; - 0 | 0 - &amp;amp;amp;infin; |         |
| DESERT       | 0 - &amp;amp;amp;infin;    | 30 - &amp;amp;amp;infin; | 0 - 0.1     |         |
| DRY_FOREST   | 50 - 1200      | 10 - 30      | 0.3 - 0.5   |         |
| MOIST_FOREST | 50 - 1200      | 10 - 30      | 0.5 - 0.8   |         |
| RAIN_FOREST  | 50 - 1200      | 20 - 40      | 0.8 - 1.0   |         |
| MOUNTAIN     | 1500 - &amp;amp;amp;infin; | -            | -           |         |

## Terrain Features

After the Biomes are placed and the heightmap is finalized by erosion simulation there are predefined features placed on the maps. This can be old temples, caves or other quest relevant artifacts for player interaction.

Usually these kind of features are depending on the kind of biome. For example a forrest biome would then run through the tree entity creation. This entities are stored in a database right when they are created via a entity blueprint.


| Biome        | Possible Features                               | Influence               |
| ------------ | ----------------------------------------------- | ----------------------- |
| ICE_DESERT   | Caverns, Ruins                                  | &amp;amp;#43;40% mineral resources  |
| MOUNTAIN     | Caverns, Artefacts                              | &amp;amp;#43;100% mineral resources |
| DRY_FORREST  | Caverns, Ruins, Artefacts, Deserted Settlements |                         |
| MOIST_FOREST | Caverns, Ruins, Artefacts, Deserted Settlements |                         |
| RAIN_FOREST  | Caverns, Ruins, Artefacts, Deserted Settlements |                         |


##  Settlement Creation

Cities usually form around natural resources like shores, rivers or rich farmland. The algorithm as described below will find suitable city position candidates and then distribute the cities in 2 to n clusters around the world map. This clustering will make sure there is enough unexplored land for the players left. It should also help with the idea of different civilization which could lead to ingame player conflicts. A possible distribution is shown in here. *TODO: Include figure*

The algorithm searches the world map and creates matrix with a mesh length of 1km.

* Rohstoffvorkommen (Farmland, Minerals, Fishing Grounds)
* Nähe zu einem Gewässer (Fluss oder Meer)


Folgende Voraussetzungen müssen gegeben sein:

* Karte mit Biom-Zuordnung muss generiert worden sein.

Aufbauen auf der Weltkarte wird eine Influence Map erstellt. Wasserwege geben einen abfallenden Wert vor. Die Auflösung der Influence Map kann geringer sein als die eigentliche Karte. Auflösungen zwischen 100m und 1km erscheinen praktikabel. Folgende Punkte werden auf der Influence Map vergeben und summiert:

* Ist das Biom praktisch um Lebensmittel anzubauen?
* Sind natürliche Ressourcen in diesem Biom vorhanden?
* Wasser Biom in der Nähe gibt Punkte.

Von der Influence Map müssen nun die Punkte entfernt werden die eindeutig keine Besiedlung ermöglichen. Folgende Punkte müssen auf 0 reduziert werden:

* Liegen im Wasser/Lava
* Liegen auf Gebirge
* Liegen im Wald
* Liegen in Gebieten mit sehr hoher Magie

Bei allen verbleibenden Punkten muss überprüft werden ob es sich um ein lokales Maximum handelt. Diese Punkte werden zusammen mit ihrer Gewichtung in eine sortierte Liste aufgenommen. Dabei kann ein wandernder Durchschnitt berechnet werden und Werte unterhalb eines gewissen Schwellwertes verworfen werden.

Koordinaten die dann zu nahe beieinander liegen (&amp;amp;lt; 3-6km) werden aus der Liste entfernt.

Anhand der Punkte auf der Liste werden die Siedlungen berechnet. Zu 70% wird eine Stadt aus der oberen Hälfte der Liste der Reihe nach entnommen. Zu 30% wird eine Siedlung zufällig aus einem Kandidaten der unteren Listenhälfte entnommen bis die Anzahl der gewünschten Siedlungen erreicht ist oder die Liste erschöpft ist. Sollte ein Listenteil erschöpft sein, so wird jeweils vom anderen Listenteil mit dem gleichen Muster vorgegangen.

Erzeugung von Städten

1. Bestimmung der Anzahl der Gebäude anhand der Populationsmenge.
2. Verteilen der Gebäude um den Stadtkern nach einer Gaußkurvenverteilung.
3. Erzeugung der Gebäude-Innenräume nach: https://en.wikipedia.org/wiki/Maze_generation_algorithm#Recursive_division_method

## Resource Distribution

TBD.

## Navigation Map Creation

The navigation map is created for NPC to fast calculate travel paths other long distances. It creates a connected graph network and the output is put into a [Neo4J database](https://neo4j.com/).

* Add nodes for each city, artefact and places of interest (poi&amp;amp;#39;s)
* Add a grid of 10 * 10 points and connect them to every next neighbour node (diagonal connections are allowed)
* Weights of these connections is calculated

The guidline for weight is 1 for a normal, easy to walk road. It gets higher for e.g. steeper terrain and if there is a slope between the points is more then its marked as climable.

In order to detect climable terrain we follow the connection between the nodes and if the slope over a distance of 5m is higher than 45° it is marked as &amp;amp;#39;climb&amp;amp;#39;. The weight for sloped terrain is:

&amp;amp;lt;span&amp;amp;gt;
  \[t = weight_{base} \cdot min(1.0, (slope - 15) \cdot \frac{4}{30})\]
&amp;amp;lt;/span&amp;amp;gt;


For waterways the weight 1 for a calm and normal flowing river.

Example weights:

* Normal road: 1
* Grassland: 1.5
* Rough Terrain: 2
* Terrain with lots bushes/thorns: 4
* Swamps: 8

Additional data labels for the connections, to later help filter them for different use cases:

* **Walk**: Connection can be traveled by food
* **Drive**: Weagons can drive on this connection (e.g. roads)
* **Swim**: Waterways connections are marked like this
* **Climb**: Conneections with slopes higher then 45 degrees are marked like this

### Node Connection Weights

&amp;amp;gt; Its possible that downscaled graphs with pre-calculated connections must be made in order to speed up NPC navigation later on.

## World Data Cleanup

Before a new world is created the old world data is deleted. The following procedure is made after all player entities are persisted and active entity simulation has stopped:

1. Delete all voxel data
2. Delete all navigation waypoint data
3. Delete all non-player entity data\)
&amp;lt;/span&amp;gt;\)
&lt;/span&gt;\)
</span>
</p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">



  <div><a class="flex align-center" href="https://github.com/tfelix/bestia-docs/commit/6c9ca596e4acc878138e5af735aa82207da0fbf0" title='Last modified by Thomas Felix | May 16, 2020' target="_blank" rel="noopener">
      <img src="/svg/calendar.svg" class="book-icon" alt="Calendar" />
      <span>May 16, 2020</span>
    </a>
  </div>



  <div>
    <a class="flex align-center" href="https://github.com/tfelix/bestia-docs/edit/master/content//docs/server/world-generation.md" target="_blank" rel="noopener">
      <img src="/svg/edit.svg" class="book-icon" alt="Edit" />
      <span>Edit this page</span>
    </a>
  </div>

</div>

 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#world-generation">World Generation</a>
      <ul>
        <li><a href="#world-generation-algorithm">World Generation Algorithm</a></li>
        <li><a href="#base-parameter">Base Parameter</a></li>
        <li><a href="#noise-maps">Noise Maps</a>
          <ul>
            <li><a href="#height-map">Height Map</a></li>
            <li><a href="#humidity-map">Humidity Map</a></li>
            <li><a href="#temperature-map">Temperature Map</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>

 
    </aside>
    
  </main>

  
</body>

</html>












