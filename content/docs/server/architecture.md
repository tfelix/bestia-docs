---
weight: 100
title: Server Architecture
description: "Overview of Bestia's event-driven server architecture, entity actor system, client-server communication, and data persistence."
draft: true
---

Bestia uses an event message based server architecture. The events are generated either by connected client messages coming in, or are internally automatically generated by the actions and timers of entities.

Bestia uses a entity actor system for management and active control of its entities. An entity is basically every being that can be interacted with in the world. Each entity is represented by an in memory actor. When entities interact they communicate via the Akka messaging system. Components are child actors of an entity actor and they can send messages to other entities or components.

# Entity Component Services

Entities are described by dynamically attaching components to them. [ECS system](https://en.wikipedia.org/wiki/Entity_component_system) have been proven as a de facto industry standard for recent game development. The components only contain the data are attached to entities which merely are an ID in the system. The so called systems act upon this data and alter the entities data, this is the case in a fixed tick amount for game logic updates. Since the Bestia system is event based and not tick based we use a little different approach: We define services which work on entities and their components. These services are triggered by Akka Actors in case a event message arrives. This architecture allows a better usage of computing resources in a clustered server environment.

A entity factory will create a entity, save it into the memdb and also start a sharded entity into the cluster. The factory will also create and setup components which might have also active actors. If a component is created, altered or deleted these calls are intercepted via a configurable callback. Usually the component instances are cached for some amount of time to lessen the strain on the garbage collector. Upon creation of the component a message might get sent into the actorsystem to start up a component based actor which will then in turn control some execution specific operation like periodic health regeneration ticks.

State of the entities is persisted by the Cassandra database and via Persistent Akka Actors.

# Client Server Communication

## Datatypes

All locations and entities are represented via fixed point numbers to avoid incorrectness with floating points over a bigger distance [(see The perils of floating point](http://www.stat.cmu.edu/~brian/711/week03/perils-of-floating-point.pdf)).

The basic datastructures for positioning and collisions are found in `net.bestia.model.geometry`. Most notable the `Vector3` datatype.

It uses long as datatypes for the coordinates and thus has a range between `-9.223.372.036.854.775.808` to
`9.223.372.036.854.775.807` which means if we can represent at the best a position resolution of 1mm. So our
maximum world size is:

| Size                    | Unit |
| :---------------------- | ---: |
| +-9.223.372.036.854.775 |    m |
| +-9.223.372.036.854     |   km |

which is more then enough.

## Binary Protocol

Bestia uses [ProtoBuf](https://developers.google.com/protocol-buffers) descrition file in order to communicate with its connected clients. The description files can be found in the [bestia-protobuf](https://github.com/tfelix/bestia-behemoth/tree/master/bestia-proto-messages) module in the main repository.

# Literature

[Save States of Actors](https://medium.com/@takezoe/save-state-of-actor-using-akka-persistence-a9111ff2c42b)
[Testing persisting actors](http://tudorzgureanu.com/akka-persistence-testing-persistent-actors/)
[Load Balancing Akka Clusters](http://blog.kamkor.me/Akka-Cluster-Load-Balancing/)